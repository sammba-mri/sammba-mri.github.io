

.. _sphx_glr_auto_examples_03_connectivity_plot_confounds.py:


Confounds exploration
=====================

Here we show how to regress out confound signals, in particular using 
statistical CompCor.

   * Y. Behzadi et al. `A Component Based Noise Correction Method (CompCor) for BOLD and Perfusion Based fMRI
     <https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2214855/>`_,
     NeuroImage Vol 37 (2007), p. 90-101


Statistical CompCor
----------------------------------------------
Retrieve the data from one subject



.. code-block:: python

    from sammba import data_fetchers

    test_retest = data_fetchers.fetch_zurich_test_retest(subjects=[1])
    fmri_filename = test_retest.func[0]







We perform a PCA to extract the 98% most variant components.
This is done by the function **nilearn.image.high_variance_confounds**,



.. code-block:: python

    from nilearn import image

    hv_array = image.high_variance_confounds(fmri_filename)
    print('Computed {0} confounds array.'.format(hv_array.shape[1]))





.. rst-class:: sphx-glr-script-out

 Out::

    Computed 5 confounds array.


Do my counfounds model noise properly? Voxel-to-voxel connectivity tells!
-------------------------------------------------------------------------
Check the relevance of chosen confounds: The distribution of voxel-to-voxel
correlations should be tight and approximately centered to zero.

Compute voxel-wise time series without confounds removal, using NiftiMasker.



.. code-block:: python

    from nilearn.input_data import NiftiMasker

    brain_masker = NiftiMasker(detrend=True, memory='nilearn_cache', verbose=1)
    timeseries_raw = brain_masker.fit_transform(fmri_filename)





.. rst-class:: sphx-glr-script-out

 Out::

    [NiftiMasker.fit] Loading data from /home/salma/nilearn_data/zurich_retest/baseline/1367/rsfMRI.nii.gz
    [NiftiMasker.fit] Computing the mask
    ________________________________________________________________________________
    [Memory] Calling nilearn.masking.compute_background_mask...
    compute_background_mask('/home/salma/nilearn_data/zurich_retest/baseline/1367/rsfMRI.nii.gz', verbose=0)
    __________________________________________compute_background_mask - 1.1s, 0.0min
    [NiftiMasker.fit] Resampling mask
    ________________________________________________________________________________
    [Memory] Calling nilearn.image.resampling.resample_img...
    resample_img(<nibabel.nifti1.Nifti1Image object at 0x2b0b832a77d0>, target_shape=None, target_affine=None, copy=False, interpolation='nearest')
    _____________________________________________________resample_img - 0.0s, 0.0min
    ________________________________________________________________________________
    [Memory] Calling nilearn.input_data.nifti_masker.filter_and_mask...
    filter_and_mask('/home/salma/nilearn_data/zurich_retest/baseline/1367/rsfMRI.nii.gz', <nibabel.nifti1.Nifti1Image object at 0x2b0b832a77d0>, { 'detrend': True,
      'dtype': None,
      'high_pass': None,
      'low_pass': None,
      'sample_mask': None,
      'sessions': None,
      'smoothing_fwhm': None,
      'standardize': False,
      't_r': None,
      'target_affine': None,
      'target_shape': None}, verbose=1, dtype=None, confounds=None, memory_level=1, memory=Memory(cachedir='nilearn_cache/joblib'), copy=True)
    [NiftiMasker.transform_single_imgs] Loading data from Nifti1Image('/home/salma/nilearn_data/zurich_retest/baseline/1367/rsfMRI.nii.gz')
    [NiftiMasker.transform_single_imgs] Extracting region signals
    [NiftiMasker.transform_single_imgs] Cleaning extracted signals
    __________________________________________________filter_and_mask - 2.1s, 0.0min


Next, compute the voxel-to-voxel correlations. We use only 1% of voxels,
to save computation time.



.. code-block:: python

    import numpy as np

    selected_voxels = range(0, timeseries_raw.shape[1], 100)
    correlations_raw = np.corrcoef(timeseries_raw[:, selected_voxels].T)







Same thing, with counfounds removed: compute voxelwise time-series



.. code-block:: python

    timeseries_cleaned = brain_masker.fit_transform(
        fmri_filename, confounds=[hv_array])
    correlations_cleaned = np.corrcoef(timeseries_cleaned[:, selected_voxels].T)





.. rst-class:: sphx-glr-script-out

 Out::

    [NiftiMasker.fit] Loading data from /home/salma/nilearn_data/zurich_retest/baseline/1367/rsfMRI.nii.gz
    [NiftiMasker.fit] Computing the mask
    [NiftiMasker.fit] Resampling mask
    ________________________________________________________________________________
    [Memory] Calling nilearn.input_data.nifti_masker.filter_and_mask...
    filter_and_mask('/home/salma/nilearn_data/zurich_retest/baseline/1367/rsfMRI.nii.gz', <nibabel.nifti1.Nifti1Image object at 0x2b0b83152350>, { 'detrend': True,
      'dtype': None,
      'high_pass': None,
      'low_pass': None,
      'sample_mask': None,
      'sessions': None,
      'smoothing_fwhm': None,
      'standardize': False,
      't_r': None,
      'target_affine': None,
      'target_shape': None}, verbose=1, dtype=None, confounds=[ array([[ 0.055905, ...,  0.120548],
           ..., 
           [ 0.035185, ...,  0.01258 ]], dtype=float32)], memory_level=1, memory=Memory(cachedir='nilearn_cache/joblib'), copy=True)
    [NiftiMasker.transform_single_imgs] Loading data from Nifti1Image('/home/salma/nilearn_data/zurich_retest/baseline/1367/rsfMRI.nii.gz')
    [NiftiMasker.transform_single_imgs] Extracting region signals
    [NiftiMasker.transform_single_imgs] Cleaning extracted signals
    __________________________________________________filter_and_mask - 2.9s, 0.0min


Plot now the histograms of both raw and cleaned correlations.



.. code-block:: python

    import matplotlib.pylab as plt

    plt.figure(figsize=(8, 5))
    plt.hist(correlations_raw[np.triu_indices_from(correlations_raw, k=1)],
             color='r', alpha=.3, bins=100, lw=0, label='raw')
    plt.hist(correlations_cleaned[np.triu_indices_from(correlations_cleaned, k=1)],
             color='b', alpha=.3, bins=100, lw=0, label='cleaned')

    [ymin, ymax] = plt.ylim()
    plt.vlines(0, ymin, ymax)
    plt.xlabel('correlation values')
    plt.title('voxel-to-voxel correlations')
    plt.legend()
    plt.tight_layout()
    plt.show()




.. image:: /auto_examples/03_connectivity/images/sphx_glr_plot_confounds_001.png
    :align: center




The correlations distribution is wider after statistical CompCor, so these
confounds are not well suited to our case.


**Total running time of the script:** ( 0 minutes  8.536 seconds)



.. container:: sphx-glr-footer


  .. container:: sphx-glr-download

     :download:`Download Python source code: plot_confounds.py <plot_confounds.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: plot_confounds.ipynb <plot_confounds.ipynb>`

.. rst-class:: sphx-glr-signature

    `Generated by Sphinx-Gallery <http://sphinx-gallery.readthedocs.io>`_
